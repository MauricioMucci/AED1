/*
Triple ref technique = pointers to pointers
- Tracer = ponteiro de ponteiro. Ao fazer isso eh possivel fzr com que aponte para os outros ponteiros de uma msm lista. 
Vantagem: ponto de referencia nao e perdido, ou seja, tracer sabe em qual elemento da lista ele esta, e ele sabe ql e o proximo
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0
typedef int BOOL;

//Estrutura que entrega os dados
typedef struct _thing 
{ 
	char *item;
	struct _thing *next;
} THING;

//Ponteiro head, ou seja, este aponta para o primeiro elemento da lista
THING *start = NULL;

// Cria um novo elemento do tipo THING a partir da string do parametro
THING *NewElement(char *text)
{
        THING *newp;
        newp = (THING *) malloc (sizeof(THING));
        newp -> item = (char *)malloc(strlen(text) + 1);
        strcpy(newp -> item, text);
        newp -> next = NULL;
        return newp;
}  


// Insere um novo elemento na lista-encadeada
// OBS.: elementos iguais nao sao verificadas
void InsertThing(THING **head, THING *newp)
{
	THING **tracer = head;
	
	// Enquanto *tracer != NULL e o novo elemento nao esta na ordem alfabetica
	while((*tracer) && strcmp((*tracer)->item, newp -> item) < 1)
	{
		//Ponteiro para pointeiro recebe o ponteiro do proximo elemento da lista
		tracer = &(*tracer)->next;
	}
	
	/*
	Nesse passo e demonstrado a vantagem do tracer:
	Como eu disse anteriormente, tracer sabe a posicao atual e a 
	proximo, logo:
	*/

	// Ponteiro do novo elemento recebe ponteiro de tracer, ou seja,
	// recebe o endereco do proximo elemento da lista na ordem alfa-
	// betica.
	newp -> next = *tracer;
	
	//Ponteiro do antecessor recebe o endereco do novo elemento
	*tracer = newp;
}

/*
	Start-> Thing1|Pointer1-> Thing2|Pointer2-> Thing3|Pointer3-> NULL

	tracer = &start <====> *tracer = &Thing1, ou seja, *tracer == *start
			  ou
	tracer = &Pointer1 <====> *tracer = &Thing2
			  ...
*/

// Deleta o primeiro elemento da lista no qual as strings sao iguais
// OBS.: elementos que nao estao na listas sao ignorados
void RemoveThing(THING **head, char *text)
{
	BOOL present = FALSE;
	THING *old;
	THING **tracer = head;

	// Enquanto *tracer != NULL e as strings forem diferentes
	while((*tracer) && !(present = (strcmp(text,(*tracer)->item) == 0 )))
		tracer = &(*tracer)->next;
	
	// Esse if lida com elementos que nao estao na lista
	if(present)
	{	
		// old recebe o conteudo a ser eliminado
		old = *tracer;
		// ponteiro passa a receber o endereco do proximo elemento
		*tracer = (*tracer)->next;
		free(old -> item); // free no espaco da string
		free(old); // free no resto do conteudo do no
	}
}

void PrintList(THING **head)
{	
	//Recebe o inicio da lista
	THING **tracer = head;

	//Enquanto *tracer != NULL
	while (*tracer) {
		printf("%s \n",(*tracer)->item);
		tracer = &(*tracer)->next;
	}
}


int main(int argc, char **argv)
{
        InsertThing(&start, NewElement("chips"));
        InsertThing(&start, NewElement("wine"));
        InsertThing(&start, NewElement("burgers"));
        InsertThing(&start, NewElement("beer"));
        InsertThing(&start, NewElement("pizza"));
        InsertThing(&start, NewElement("zucchini"));
        InsertThing(&start, NewElement("burgers"));
        InsertThing(&start, NewElement("slaw"));
        printf("\nINITIAL LIST\n");
        PrintList (&start);
        RemoveThing(&start, "pizza");
        RemoveThing(&start, "zucchini");
        RemoveThing(&start, "burgers");
        printf("\nALTERED LIST\n");
        PrintList(&start);
                
}